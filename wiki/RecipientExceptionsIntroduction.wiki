#summary - Recipient exceptions are designed to make code cleaner and easier to read. If you think unit test save time then definetly you must take a look to recipient exceptions. In fact, unit tests and recipient exceptions can be really good friends. Your unit test will be must happier once they meet recipient Exceptions.

= Introduction =

The name comes follows the sender/recipient nomenclature of (e)mails. Ussually libraries generate exceptions such as IOException, SQLException, DivisionByZero exceptions. Such exceptions will be treated as sender exceptions. Next let me present what recipient Exceptions will be:

recipient Exceptions are based on the next "axiom":
* ". In order to fix/solve software exceptions as soon as possible sender exceptions must always be trapped and transformed in three categories of recipient exceptions when creating a production system: user exceptions, administrator exceptions, implementation exceptions" *

= Details =

Notice I speak about production systems. Libraries or modules are not production systems so they don't have any need to trap and transform sender exceptions in recipient Exceptions. The reason is that libraries or modules have no a-priory runtime context, so it makes no sense to speak about users, administrators of implementations.

The verb "to transform" can be interpreted as "to classify", since our code will trap
the sender exception and according to the context where it's trapped it will transform/classify it into a new recipient Exception addressing a user, administrator or "implementation exception".

Notice I speak about users or administrators but not about "implementators" (developers/programmers). That's maybe to highlight the idea that user and administrator exceptions can not be avoided since it scape the control of our software (a user mistake while filling a form or a power down). On the opposite implementations exceptions can be controlled while developing our code and, ideally, a final product never must raise implementation exception. Actually, unit tests and "quality assurance" must be the recipients of implementation exceptions. That's one reason why recipient exceptions are so unit-test friendly. You can just unit test your "piece of code" by sending input values and checking whether or not recipient Exceptions where thrown. Unit tests catch exceptions not planned while developing code while recipient Exceptions help such tests be easier/more intuitive to write. When the code grows in complexity and many layers of code are glummed together is all but easy to design correct Unit Tests. Still if your code uses recipient exceptions unit tests will be able to test where is true or not that a userException was thrown or whether a set of input values threw or not an implementation exception.

- User Exceptions are those originated by an "external" user error, like sending non-correct or empty values. We will try to return such exceptions to the "external" user.
Our app is not responsible of user errors and will take no further actions.

- Administrator Exceptions are those originated by a network problem, server shutdown,
or any other problem that must be solved by the proper system administrator.
It can be possible/impossible for our software to fix the issue, for example trying to
reconect to a database or trying to create a non-existing file. If that's not the case
a new administrator Exception will be raised so that the people in charge takes care.

- Implementation Exceptions are those originated by an error in our code, usually
a non-valid state for a variable, or an impossible logical condition. Are closely related to "assert" checks. Unit tests must capture such exception so they will never be raised in
production code. Extreme programming suggest to desing unit-tests before starting to code. I agree, that's a good programming practice, but in real world is not always possible to imagine perfect unit-tests, since time, resources and knowledge constraints force us to make "blur-APIs" with parcial functionality. Still, it's easier to make "blur unit-tests" with sentences like "Try to read a document with wrong permissions" and check whether the expected user exception was thrown or an administrator/implementation exception was raised or no no recipient exceptions were thrown.

As soon as a new sender exception is triggered we will try to trap it and classify it. Then the common approach will be to "lift up the stack" to the proper recipient Exception controller. In a web app, for example, the recipient Exception controller can be the normal webapp servlet controller. In a GUI app the "main loop" could be used. In a "complex" server app, it quite ussual to have N different threads in charge of N different asynchronous tasks. In such case the "main loop" for each thread will be responsible to capture recipient Exceptions and play sensible with them. "Play sensible" means for example that a web app controller will return an error page to the user with a explanation of the user error in somewhere else in the code (maybe 5 levels "down the stack") a userException was raised. It will return a polite message to the user if an administrator exception was raised (for example a database connection error or a full-disk quota error) and log the error or email the system administrator if possible. If an implementationException was found it will (ideally) try to use a "bugzilla" system to contact the software developer. Whether the recipient exception was detected sooner or later, our functions will limit themselves to raise up the stack to the controller.

- As a best-practice approach recipient Exceptions will be created with a description, a detail and a (possible) solution. Don't forget the final purpose is to fix/solve exception as soon as possible.

- Again, recipient Exceptions must be used for final app code, not base libraries, since there is no way "a priory" for a general purpose library to known, for example, whether an
empty string is caused by an user mistake or a implementation/programming mistake. Base
libraries must use the normal (sender) exceptions, (I/O Error, "null exceptions",...).
Final apps (production code) must generate recipientExceptions.